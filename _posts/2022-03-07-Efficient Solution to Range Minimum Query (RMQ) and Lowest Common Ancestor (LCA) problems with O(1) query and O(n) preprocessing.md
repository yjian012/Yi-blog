---
title: Efficient Solution to Range Minimum Query (RMQ) and Lowest Common Ancestor (LCA) problems with O(1) query and O(n) preprocessing
date: 2022-03-07
---
<script src="/Yi-blog/js/scripts.js"></script>
<link rel="stylesheet" href="/Yi-blog/css/styles.css">
<p>I found this interesting article&nbsp;<a href="https://www.topcoder.com/thrive/articles/Range%20Minimum%20Query%20and%20Lowest%20Common%20Ancestor"><span style="color: #2b00fe;">Range Minimum Query and Lowest Common Ancestor</span></a>&nbsp;after I read about BIT on the same site (it's the best explanation of how BIT works comparing to other articles imo, so I looked for some other interesting stuff).</p><p>After I read through it, I decided to implement it. I posted it <a href="https://github.com/yjian012/algorithms-with-cpp/blob/main/Range%20Minimum%20Query%20(RMQ)%20and%20Lowest%20Common%20Ancestor%20(LCA)%20Solution%2C%20O(1)%20query%20and%20O(n)%20preprocessing.cpp"><span style="color: #2b00fe;">here</span></a>.</p>
It's a nice article, except that the last section "AN &lt;O(N), O(1)&gt; ALGORITHM FOR THE RESTRICTED RMQ" is very confusing. The last two sentences of the first paragraph say that
<div>
<blockquote style="text-align: left;">"It’s obvious that elements in A can be just +1 or -1. Notice that the old value of A[i] is now the sum of A[1], A[2] … A[i] plus the old A[0]. However, we won’t need the old values from now on."</blockquote>
<p>But then in the next paragraph, it says</p>
<blockquote>"Let A’[i] be the minimum value for the i-th block in A and B[i] be the position of this minimum value in A."</blockquote>
<p>It doesn't make much sense, since A is just a +1 -1 array, what's the point of finding the minimum in this array? I thought this must be a mistake, and I searched for some clarification.</p><p>There're not many discussions on this topic, probably because it's not quite practical. But from the few pages that I found, I confirmed my suspicion and figured out how it works, and it worked as expected.</p><p>Is it an overkill? Most likely. Having an O(log N) speedup - and it's only on the preprocessing time - is not a very big impact, and it's much more complicated than a simple ST.</p><p>Nonetheless, it's already surprising that it can be done at all! And I learned something new.</p><p>Someone <a href="https://codeforces.com/blog/entry/52961?#comment-370262"><span style="color: #2b00fe;">mentioned</span></a> that the algorithm can be <a href="https://epubs.siam.org/doi/abs/10.1137/090779759">simplified</a>. Well, it already took me a weekend, so I won't spend more time on it. But I'll take a look of that paper when I have some spare time...</p>
</div>